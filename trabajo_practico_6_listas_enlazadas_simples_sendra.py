# -*- coding: utf-8 -*-
"""SERGIO Trabajo practico 6 - Listas enlazadas simples.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1w9DdhMUxfQkfKaF8D96m_6-d15GGDcQX

# ![alt text](https://upload.wikimedia.org/wikipedia/commons/thumb/c/c3/Python-logo-notext.svg/50px-Python-logo-notext.svg.png) **Trabajo Práctico 6: Listas enlazadas simples** ![alt text](https://upload.wikimedia.org/wikipedia/commons/thumb/c/c3/Python-logo-notext.svg/50px-Python-logo-notext.svg.png)

En este trabajo práctico, vamos a trabajar iterativamente con la estructura de datos **Lista enlazada simple** en Python. Recuerden crear una copia de este archivo en su ***Google Drive*** para tener permisos de edición.

### **En los ejercicios de esta guía, no pueden usar para nada las Listas de Python, si deben declarar una lista para algo, usen la implementada por ustedes.**

### **Para implementar las operaciones del TDA Lista, tienen que trabajar con los nodos internos de las listas, no con las listas desde afuera.**

### Sergio: **sergio.gonzalez@unahur.edu.ar** ###
### Ariel: **aclocchi@gmail.com** ###

### **Ejercicio 1**

Implementar el TDA Lista enlazada simple, con las siguientes operaciones:
- **\_\_init__():** Constructor
- **Vaciar**
- **Agregar elemento al final (append):** Inserta nuevo nodo al final de la lista con el elemento que recibe como parámetro.
- **Insertar elemento:** Recibe un elemento y una posición como parámetro e inserta un nuevo nodo con el elemento en esa posición. Si la posicion es mayor al tamaño de la lista, el elemento se inserta al final. 
- **Obtener elemento:** Recibe una posición y retorna el elemento del nodo en esa posición.
- **Eliminar elemento:** Recibe una posición y elimina el nodo en esa posición.
- **Obtener tamaño de lista**.
- **Esta vacía**.
- **Clonar**
- **\_\_repr__():** Para poder imprimir una Lista por consola

**Nota: Cuando usamos posiciones en las listas, tener en cuenta que los indices empiezan en cero, es decir, el primer elemento de la lista esta en la posicion cero.**
"""

######### IMPLEMENTACION NO RECURSIVA DE LISTAS ENLAZADAS ##########

class NodoLista:
  def __init__(self, dato = None):
    self.dato = dato
    self.siguiente = None
  
  def tieneSiguiente(self):
    return self.siguiente != None

class Lista:
  def __init__(self):
    self.primero = None
  
  def estaVacia(self):
    return self.primero == None

  def vaciar(self):
    self.primero = None

  def __repr__(self):
    strOut = "primero"
    actual = self.primero
    while actual != None:
      strOut += " -> " + str(actual.dato)
      actual = actual.siguiente
    strOut += " -|"
    return strOut
  
  def append(self, dato = None):
    nuevo = NodoLista(dato)
    if self.estaVacia():
      self.primero = nuevo
    else:
      actual = self.primero
      while actual.tieneSiguiente():
        actual = actual.siguiente
      actual.siguiente = nuevo

  def len(self):
    cont = 0
    actual = self.primero
    while actual != None:
      cont += 1
      actual = actual.siguiente
    return cont
    
  def obtenerElemento(self, posDato):
    if 0 <= posDato < self.len():
      posActual = 0
      actual = self.primero
      while posActual < posDato:
        actual = actual.siguiente
        posActual += 1
      return actual.dato
    else:
      raise Exception("Posicion incorrecta")
    
  def insertarElemento(self, dato, posDato):
    nuevo = NodoLista(dato)
    if 0 < posDato < self.len():
      posActual = 0
      actual = self.primero
      while posActual < posDato-1:
        actual = actual.siguiente
        posActual += 1
      nuevo.siguiente = actual.siguiente
      actual.siguiente = nuevo
    elif posDato == 0:
      nuevo.siguiente = self.primero
      self.primero = nuevo
    elif posDato >= self.len():
      self.append(dato)
    else:
      raise Exception("Posicion incorrecta")

  def eliminarElemento(self, posDato):
    if 0 < posDato < self.len():
      posActual = 0
      actual = self.primero
      while posActual < posDato-1:
        actual = actual.siguiente
        posActual += 1
      actual.siguiente = actual.siguiente.siguiente
    elif not self.estaVacia() and posDato == 0:
      self.primero = self.primero.siguiente
    else:
      raise Exception("Posicion incorrecta")

  def clonar(self):
    nueva = Lista()
    actual = self.primero
    while actual != None:
      nueva.append(actual.dato)
      actual = actual.siguiente
    return nueva


lista1 = Lista()
lista1.append(10);lista1.append(5);lista1.append(1);lista1.append(4);lista1.append(15)

print(lista1)

lista2 = lista1.clonar()

print(lista2)

class NodoLista:
  def __init__(self, dato = None):
    self.dato = dato
    self.siguiente = None
  
  def tieneSiguiente(self):
    return self.siguiente != None

  def len(self):
    cont = 0
    if self.tieneSiguiente():
      cont = 1 + self.siguiente.len()
    else:
      cont = 1
    return cont

  def append(self, nodoNuevo):
    if not self.tieneSiguiente():
      self.siguiente = nodoNuevo
    else:
      self.siguiente.append(nodoNuevo)

  def obtenerElemento(self, posDato, posActual = 0):
    dato = None
    if posActual == posDato:
      dato = self.dato
    else:
      dato = self.siguiente.obtenerElemento(posDato, posActual+1)
    return dato

  def insertar(self, nodoNuevo, posNuevo, posActual = 0):
    if posActual == posNuevo-1:
      nodoNuevo.siguiente = self.siguiente
      self.siguiente = nodoNuevo
    else:
      self.siguiente.insertar(nodoNuevo, posNuevo, posActual+1)

  def eliminar(self, posEliminar, posActual = 0):
    if posActual == posEliminar-1:
      self.siguiente = self.siguiente.siguiente
    else:
      self.siguiente.eliminar(posEliminar, posActual+1)

  def clonar(self, listaNueva):
    listaNueva.append(self.dato)
    if self.tieneSiguiente():
      self.siguiente.clonar(listaNueva)

##No funciona
#  def clonar(self):
#    listaNueva = Lista()
#    listaNueva.append(self.dato)
#    if self.tieneSiguiente():
#      self.siguiente.clonar(listaNueva)
#    return listaNueva

class Lista:
  def __init__(self):
    self.primero = None
  
  def estaVacia(self):
    return self.primero == None

  def vaciar(self):
    self.primero = None

  def __repr__(self):
    strOut = "primero"
    actual = self.primero
    while actual != None:
      strOut += " -> " + str(actual.dato)
      actual = actual.siguiente
    strOut += " -|"
    return strOut
  
  def len(self):
    cont = 0
    if not self.estaVacia():
      cont = self.primero.len()
    return cont

  def append(self, dato = None):
    nodoNuevo = NodoLista(dato)
    if self.estaVacia():
      self.primero = nodoNuevo
    else:
      self.primero.append(nodoNuevo)

  def obtenerElemento(self, posDato):
    dato = None
    if not self.estaVacia() and 0 <= posDato < self.len():
      dato = self.primero.obtenerElemento(posDato)
    else:
      raise Exception("Posicion incorrecta")
    return dato

  def insertar(self, dato, posDato):
    nodoNuevo = NodoLista(dato)
    if 0 <= posDato < self.len():
      self.primero.insertar(nodoNuevo, posDato)
    elif self.estaVacia() and posDato >= 0:
      self.primero = nodoNuevo
    elif posDato >= self.len():
      self.primero.append(nodoNuevo)
    else:
      raise Exception("Posicion incorrecta")

  def eliminar(self, posDato):
    if 0 < posDato < self.len():
      self.primero.eliminar(posDato)
    elif posDato == 0 and not self.estaVacia():
      self.primero = self.primero.siguiente
    else:
      raise Exception("Posicion incorrecta")

  def clonar(self):
    listaNueva = Lista()
    if not self.estaVacia():
      self.primero.clonar(listaNueva)
    return listaNueva


lista = Lista()
lista.insertar(10,0)
print(lista)
lista.append(2);lista.append(4);lista.append(1);lista.append(2);lista.append(9);lista.append(5)
print(lista)

lista.insertar(10,30)
print(lista)

lista.eliminar(0)
print("lista",lista)
lista2 = lista.clonar()
print("lista2",lista2)

"""### **Ejercicio 2**

Escribir una operación del TDA Lista que intercambie los dos primeros nodos de la lista.
"""

class Lista(Lista):
  def intercambiaPrimeros(self):

"""### **Ejercicio 3**

Escribir la operación del TDA Lista **buscaElemento()** que busque un elemento que recibe por parámetro. La operación debe retornar una lista con las ubicaciones del elemento en la lista de entrada.

Por ejemplo:

**lista1** = [ 2 , 2 , 1 , 4 , 2 , 8 , 9 , 2 , 10]

**posiciones = lista1.buscaElemento(2)**

Entonces, **posiciones** = [ 0 , 1 , 4 , 7 ]
"""

class NodoLista(NodoLista):
  def buscaElemento(self, dato, listaPosiciones, posActual = 0):
    if self.dato == dato:
      listaPosiciones.append(posActual)
    if self.tieneSiguiente():
      self.siguiente.buscaElemento(dato, listaPosiciones, posActual+1)

class Lista(Lista):
  def buscaElemento(self, dato):
    listaPosiciones = Lista()
    if not self.estaVacia():
      self.primero.buscaElemento(dato, listaPosiciones)
    return listaPosiciones

lista = Lista()
lista.append(2);lista.append(2);lista.append(1);lista.append(4);lista.append(2);
lista.append(8);lista.append(9);lista.append(2);lista.append(10);
print(lista)
print(lista.buscaElemento(2))

"""### **Ejercicio 4**

Escribir una operación del TDA Lista que elimine todas las ocurrencias de un elemento que recibe por parámetro y devuelva la cantidad de veces que se elimino el elemento. Se deben eliminar todos los nodos que contengan al elemento.

Por ejemplo:

**lista1** = [ 2 , 2 , 1 , 4 , 2 , 8 , 9 , 2 , 10]

**cant = lista1.eliminarOcurrencias(2)**

Entonces, **cant** = 4  y **lista1** = [ 1 , 4 , 8 , 9 , 10 ]

          
"""

class NodoLista(NodoLista):
  def eliminarOcurrencias(self, datoEliminar):
    cant = 0
    if self.tieneSiguiente():
      if self.siguiente.dato == datoEliminar:
        self.siguiente = self.siguiente.siguiente
        cant = 1 + self.eliminarOcurrencias(datoEliminar)
      else:
        cant = self.siguiente.eliminarOcurrencias(datoEliminar)
    return cant

class Lista(Lista):
  def eliminarOcurrencias(self, datoEliminar):
    cant = 0
    while not self.estaVacia() and self.primero.dato == datoEliminar:
      self.primero = self.primero.siguiente
      cant += 1
    if not self.estaVacia(): 
      cant += self.primero.eliminarOcurrencias(datoEliminar)
    return cant

lista = Lista()
lista.append(2);lista.append(2);lista.append(1);lista.append(4);lista.append(2);
lista.append(8);lista.append(9);lista.append(2);lista.append(10);lista.append(2)
print(lista)

print(lista.eliminarOcurrencias(2))
print(lista)

"""### **Ejercicio 5**

Escribir una operación del TDA Lista que saque el nodo que esta al inicio de la lista (posición cero) y lo ponga en el final. Hacer otra que haga lo contrario, saque el nodo del final y lo ponga al inicio.
"""



"""### **Ejercicio 6**

Escribir una operación del TDA Lista que reemplaze todas las ocurrencias de un numero por otro. Ambos números los recibe por parámetro.

Por ejemplo:


**lista1** = [ 2 , 1 , 4 , 8 , 9 , 2 , 5 , 12 , 10]

**lista1.reemplazar(2,3)** #Reemplaza todos los 2 por 3

Entonces, **lista1** = [ 3 , 1 , 4 , 8 , 9 , 3 , 5 , 12 , 10 ]
"""



"""### **Ejercicio 7**

Escribir la operación **duplicar()** del TDA Lista que duplica el contenido de una lista.

Por ejemplo:

**lista1** = [ 2 , 1 , 4 , 8 , 9 ]

**lista1.duplicar()**

Entonces, **lista1** = [ 2 , 1 , 4 , 8 , 9 , 2 , 1 , 4 , 8 , 9 ]
"""



"""### **Ejercicio 8**

Los recorridos de listas normalmente pasan por todos los nodos, empezando por el primero, luego al siguiente, etc, como en la siguiente figura:


![texto alternativo](https://i.ibb.co/DD1SXP9/recorrido-lista.png)


Escribir una operación del TDA Lista que recorra la lista salteandose de a un nodo y mostrando por pantalla los elementos de los nodos visitados. El recorrido debe ser asi:

![texto alternativo](https://i.ibb.co/q7xjDkZ/recorrido-salteado-lista.png)

Por ejemplo:

**lista1** = [ 2 , 1 , 4 , 8 , 9 , 12 , 5 , 8 ]

**lista1.recorridoSalteado()**

2

4

9

5


**Nota: No es correcto hacer un recorrido secuencial e ir contando las posiciones, lo correcto es solo visitar los nodos que nos interesan**
"""



"""### **Ejercicio 9**

Vamos con otro tipo de recorrido de listas, escribir una operación del TDA Lista que recorra la lista de la siguiente manera (mientras va imprimiendo los elementos del nodo visitado):
- Si el elemento del nodo visitado es par, seguimos por el siguiente
- Si el elemento del nodo visitado es impar, nos salteamos el siguiente y seguimos con el otro

El recorrido debe ser asi:

![texto alternativo](https://i.ibb.co/DkBKs5M/recorrido-salteadopar-lista.png)

Por ejemplo:

**lista1** = [ 2 , 5 , 1 , 9 , 8 , 10 , 7 ]

**lista1.recorridoParImpar()**

2

5

9

10

7

"""



"""### **Ejercicio 10**

Escribir una operación del TDA Lista que recibe dos números por parámetro. La operación recorre la lista, si el elemento del nodo es menor que el primer parámetro se deja igual, si es mayor o igual, se reemplaza por el mismo número multiplicado por el otro parámetro.

Por ejemplo:

**lista1** = [ 2 , 1 , 4 , 8 , 9 , 12 , 0 , 10 , 1 , 4 ]

**lista1.reemplazaMayores(6,3)** #Multiplica por 3 los mayores o iguales a 6, el resto queda igual

Entonces, **lista1** = [ 2 , 1 , 4 , 24 , 27 , 36 , 0 , 30 , 1 , 4 ]

"""



"""### **Ejercicio 11**

Escribir una operación del TDA Lista que recibe dos números por parámetro: una posición y un número nuevo. Recorre la lista hasta la posición y reemplaza el número de la lista por el nuevo.

Por ejemplo:

**lista1** = [ 2 , 1 , 4 , 8 , 9 , 12 , 0 , 10 , 1 , 4 ]

**lista1.reemplazar(2,20)** #Reemplaza el número en la posición 2 por 20

Entonces, **lista1** = [ 2 , 1 , 20 , 8 , 9 , 12 , 0 , 10 , 1 , 4 ]
"""



"""### **Ejercicio 12**

Escribir la operación **insertarOrdenado()** del TDA Lista, que se llama desde una lista ordenada e inserta un número que recibe por parámetro en el lugar correcto (manteniendo el orden).

Por ejemplo:

**lista1** = [ 2 , 5 , 9 , 12 , 25 , 32 ]

**lista1.insertarOrdenado(10)**

Entonces, **lista1** = [ 2 , 5 , 9 , 10 , 12 , 25 , 32 ]
"""



"""### **Ejercicio 13**

Escribir una operación del TDA Lista que intercambie dos nodos cualquiera de la lista, cuyas posiciones se reciben por parámetros. Se deben intercambiar los nodos, no solo los elementos.
"""

