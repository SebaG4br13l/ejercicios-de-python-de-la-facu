# -*- coding: utf-8 -*-
"""Trabajo practico 2 Tipos de datos Abstractos SENDRA .ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1ECfxjhIU1cwFt_yx0dBUuD4hiZdAQJyM

# ![alt text](https://upload.wikimedia.org/wikipedia/commons/thumb/c/c3/Python-logo-notext.svg/50px-Python-logo-notext.svg.png) **Trabajo Práctico 2: Tipos de datos abstractos** ![alt text](https://upload.wikimedia.org/wikipedia/commons/thumb/c/c3/Python-logo-notext.svg/50px-Python-logo-notext.svg.png)

En este trabajo práctico, vamos a trabajar con la definición de tipos de datos abstractos en Python. Recuerden crear una copia de este archivo en su ***Google Drive*** para tener permisos de edición.

### Sergio: **sergio.gonzalez@unahur.edu.ar** ###
### Ariel: **aclocchi@gmail.com** ###

**En cada ejercicio, luego de implementar el TDA pedido, tienen que probar cada una de las operaciones en un programa principal, ejecutando cada una de ellas**

**En el video les comenté de la función \_\_str__ para la representación de variables de los TDAs, en lugar de \_\_str__ pueden implementar \_\_repr__ que es similar pero más general (No solo sirve para el *print*, sino para la representación en general de variables del TDA)**

### **Ejercicio 1**

Implementar el TDA "Propiedad" que modela un inmueble, con una estructura definida por los siguientes componentes:
- Calle
- Número
- Localidad
- Año de construcción
- Cantidad de ambientes

Implementar las siguientes operaciones:
- Constructor: Debe incluir las validaciones necesarias, teniendo en cuenta que solo se almacenan propiedades construidas luego de 1870.
- \_\_repr__: Al usar la función *print* con una variable del tipo propiedad debe mostrar: **'calle' 'numero' ('localidad')**.
- mismaLocalidad: Operación que recibe dos propiedades y retorna *True* si estan en la misma localidad y *False* en caso contrario.
- mayorNumeración: Operación que recibe dos propiedades y si están en la misma calle, retorna la que posee mayor numeración. Si están calles diferentes debe lanzar una excepción.
- calculaImpuestoARBA: Operación que retorna el porcentaje de impuesto inmobiliario de una propiedad, según la siguiente regla:
 - Propiedades entre 1870 y 1949:
   - Entre 1 y 3 ambientes: 5% de impuesto
   - Entre 4 y 6 ambientes: 10% de impuesto
   - Más de 6 ambientes: 25 % de impuesto
 - Propiedades desde 1950 hasta la actualidad:
   - Entre 1 y 5 ambientes: 5% de impuesto
   - Más de 5 ambientes: 35 % de impuesto
"""

def validaAnio(anio):
  if isinstance(anio, int) and anio >= 1870:
    return anio
  else:
    raise Exception("El año debe ser mayor o igual a 1870.")
def validaString(cadena, nombre):
  if isinstance(cadena, str):
    return cadena
  else:
    raise Exception("La "+nombre+" debe ser un string.")
def validaPositivo(numero, nombre):
  if isinstance(numero, int) and numero > 0:
    return numero
  else:
    raise Exception(nombre+" debe ser un numero positivo.")

class Propiedad:
  def __init__(self, calle, numero, localidad, anioConstruccion, cantAmbientes):
    self.calle = validaString(calle, "calle")
    self.numero = validaPositivo(numero, "numero")
    self.localidad = validaString(localidad, "localidad")
    self.anioConstruccion = validaAnio(anioConstruccion)
    self.cantAmbientes = validaPositivo(cantAmbientes, "cantAmbientes")
  
  def __repr__(self):
    return str(self.calle) +" " + str(self.numero) + " (" + self.localidad + ")"

  def mismaLocalidad(self, prop2):
    return self.localidad == prop2.localidad

  def obtenerCalle(self):
    return self.calle

  def modificaCalle(self, calleNueva):
    self.calle = validaString(calleNueva, "calle")

  def clonar(self):
    return Propiedad(self.calle, self.numero, self.localidad, self.anioConstruccion, self.cantAmbientes)

  def __eq__(self, prop2):
    return self.calle == prop2.calle and self.numero == prop2.numero and self.localidad == prop2.localidad and \
           prop2.anioConstruccion == prop2.anioConstruccion and self.cantAmbientes == prop2.cantAmbientes

def propiedadesEnMismaCalle(prop1, prop2):
  return prop1.obtenerCalle() == prop2.obtenerCalle()

prop1 = Propiedad("San Martin", 500, "A", 2000, 5)
prop2 = Propiedad("San Martin", 500, "A", 2000, 5)

prop1.modificaCalle("Belgrano")

"""### **Ejercicio 2**

Implementar el TDA "Quiniela" que modela un juego de quiniela con dos números premiados. La estructura contiene:
- Primer número premiado
- Segundo número premiado
- Multiplicador (cuánto se paga por cada peso apostado)

Implementar las siguientes operaciones:
- Constructor: Debe incluir las validaciones necesarias, teniendo en cuenta que los números que participan se encuentran entre 0 y 999.
- \_\_repr__: Al usar la función *print* con una variable del tipo quiniela debe mostrar: **Primer número ganador: 'numero' - Segundo número ganador: 'numero' - Paga: 'multiplicador'X**.
- esNumeroGanador: Operación que recibe un número por parámetros y retorna *True* si el número resultó ganador o *False* en caso contrario.
- importeAPagar: Operación que recibe un número y el monto apostado por parámetros y retorna el importe a pagar si la apuesta es ganadora o 0 en caso contrario. Si el número es el primer premio, se paga 'mutiplicador' por cada peso apostado, si es el segundo premio se paga la mitad. Solo se aceptan apuestas hasta $1000.
- premiadosCercanos: Operación que retorna *True* si los números premiados están a menos de 10 números de distancia y *False* en caso contrario. 



"""

#Se implementa el tipo quiniela.
class Quiniela:
  def __init__(self, primerNumeroPremiado, segundoNumeroPremiado, multiplicador):
    self.primerNumeroPremiado = validaPremio
    self.segundoNumeroPremiado = 
    self.multiplicador = 


  #se implementa la funcion __repr__ que permite representarla por consola mendiante
  #la funcion print muestra los primeros premios y el factor multiplicador con strings 
  def __repr__(self):
    return 'Primer número ganador: 'str(self.primerNumeroGanador) + ' - ' + 'Segundo número ganador: ' str(self.segundoNumeroPremiado) + ' - ' + 'Paga: 'str(self.multiplicador)

 #se implementa la funcion esNumeroGanador() 
  def esNumeroGanador(numero):
    if numero == primerNumeroGanador:
      return true 

  #Se implementa la funcion importeAPagar() 
  def importeAPagar(numero, monto):
    return importe
  
  #Se implementa la función premiadosCercanos()       
  def premiadosCercanos():

"""### **Ejercicio 3**

Implementar el TDA "Cuenta" que modela una cuenta bancaria, la estructura de datos esta compuesta por los siguientes componentes:
- Número de cuenta
- DNI del titular
- Saldo de cuenta actual
- Interés anual

Implementar las siguientes operaciones:
- Constructor: Debe incluir las validaciones necesarias.
- \_\_repr__: Al usar la función *print* con una variable del tipo cuenta debe mostrar: **Cuenta Nro: 'numero' - Titular: 'dni' ($'saldo')**.
- actualizarSaldo: Operación que actualiza el saldo de la cuenta aplicándole el interés diario (interés anual dividido entre 365).
- ingresarDinero: Operación que recibe un número e ingresa esa cantidad en la cuenta.
- retirarDinero: Operación que recibe un número y extrae esa cantidad de la cuenta (si hay saldo disponible), sino debe lanzar una excepción.
"""

def validaCuenta(numeroDeCuenta):
  if isinstance(numeroDeCuenta, int) and numeroDeCuenta <= 100000000:
    return numeroDeCuenta
  else:
    raise Exception(numeroDeCuenta+' es un ingreso inválido. numeroDeCuenta debe ser un número entero posivito, menor a 100000000.') 
def validaDNI(dniDelTitular):
  if isinstance(dniDelTitular, int) and dniDelTitular >= 6000000:
    return dniDelTitular
  else:
    raise Exception(dniDelTitular+' es incorrecto, por favor ingrese un DNI válido')
def validaSaldo(saldoDeCuentaActual):
  if isinstance(saldoDeCuentaActual, float):
    return saldoDeCuentaActual
def validaInteres(interesAnual):
  if isinstance(interesAnual, float) and interesAnual < 1:
    return interesAnual
  else:
    raise Exception(interesAnual+' no es válido')

class Cuenta:
  def __init__(self, numeroDeCuenta, dniDelTitular, saldoDeCuentaActual, interesAnual):
    self.numeroDeCuenta = validaCuenta(numeroDeCuenta)
    self.dniDelTitular = validaDNI(dniDelTitular)
    self.saldoDeCuentaActual = validaSaldo(saldoDeCuentaActual)
    self.interesAnual = validaInteres(interesAnual)
  
  def __repr__(self):
    return 'Cuenta Nro: '+str(self.numeroDeCuenta) + ' - Titular: '+ str(self.dniDelTitular) + ' ( $'+ str(self.saldoDeCuentaActual)+ ' )'
  
  def actualizarSaldo():
    return
  def ingresarDinero():
    return
  def retirarDinero():
    return

cuenta1= Cuenta(2345678, 34296738, 15000.0, 0.3)
print(cuenta1)

"""### **Ejercicio 4**

Implementar el TDA "Tiempo" que modela una duracion en horas, minutos y segundos.

Se deben implementar las siguientes operaciones:
- Constructor: Debe incluir las validaciones necesarias, la hora debe ser un número positivo y los minutos y segundos deben ser números positivos entre 0 y 59.
- \_\_repr__: Al usar la función *print* con una variable del tipo tiempo debe mostrar: **'horas':'minutos':'segundos'**.
- tiempoASegundos: Operación que toma una variable de tipo tiempo y retorna la cantidad en segundos.
- tiemposDesdeSegundos: Operación que recibe un tiempo en segundos como parámetro y retorna una variable de tipo tiempo, en horas minutos y segundos. 
- mayorDuracion: Operación que recibe dos variables de tipo tiempo y retorna la de mayor duración.
"""

class Tiempo:
  def __init__(self, horas, minutos, segundos):
    self.horas = horas
    self.minutos = minutos
    self.segundos = segundos
  
  def __repr__(self):
    return str(self.horas) + ":" + str(self.minutos) + ":" + str(self.segundos)

  def tiempoDesdeSegundos(segundos):
    horas = segundos // 3600
    minutos = (segundos % 3600) // 60
    segundos = (segundos % 3600) % 60
    return Tiempo(horas, minutos, segundos)


t1 = Tiempo(1,32,34)
print(t1)

"""### **Ejercicio 5**

Las plataformas de música online como ***YouTube*** y ***Spotify*** almacenan la información asociada a las canciones en estructuras de datos complejas para hacer las búsquedas de manera eficiente. Para esto se deben modelar las canciones. Implementar el TDA "Cancion" con los siguientes componentes:
- Nombre
- Artista
- Duración
- Género musical (6 posibles: Rock, Jazz, Blues, Funk, Reggae y Rap).
- Año de edición
- Número de likes

Implementar las siguientes operaciones:
- Constructor: Debe incluir las validaciones necesarias.
- \_\_repr__: Al usar la función *print* con una variable del tipo canción debe mostrar: **'nombre' - 'artista' ('duracion')**.
- mayorDuracion: Operación que recibe dos canciones por parámetros y retorna la de mayor duración.
- agregaLikes: Operación que recibe un número e incrementa la cantidad de likes de la canción en ese número.
- masVotada: Operacion que recibe dos canciones y sin son del mismo artista y del mismo género musical, retorna la que tiene mayor cantidad de likes. En caso contrario debe lanzar una excepción.
"""

def validaDuracion(tiempo):
  if isinstance(tiempo, Tiempo):
    return tiempo
  else:
    raise Exception("La duracion debe ser una variable de tipo Tiempo")

class Cancion:
  def __init__(self, nombre, artista, duracion, genero, anio, nLikes):
    self.nombre = nombre
    self.artista = artista
    self.duracion = validaDuracion(duracion)
    self.genero = genero
    self.anio = anio
    self.nLikes = nLikes

canc1 = Cancion("sdsd", "sddsd", Tiempo(1,2,3), "sdsd", 2010, 20)