# -*- coding: utf-8 -*-
"""Copia de Trabajo practico 7 - Arboles binarios de busqueda.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1JMN8p3H35cjgqhq2VB2dfrvekuvgY4rx

# ![alt text](https://upload.wikimedia.org/wikipedia/commons/thumb/c/c3/Python-logo-notext.svg/50px-Python-logo-notext.svg.png) **Trabajo Práctico 7: Árboles binarios de búsqueda** ![alt text](https://upload.wikimedia.org/wikipedia/commons/thumb/c/c3/Python-logo-notext.svg/50px-Python-logo-notext.svg.png)

En este trabajo práctico, vamos a trabajar con las estructuras de datos **Árbol binario de búsqueda** en Python. Para esta guía, los datos que guardaremos en los nodos son números enteros. Recuerden crear una copia de este archivo en su ***Google Drive*** para tener permisos de edición.

### Sergio: **sergio.gonzalez@unahur.edu.ar** ###
### Ariel: **aclocchi@gmail.com** ###

### **Ejercicio 1**

Implementar el TDA Árbol binario de búsqueda, con las siguientes operaciones:

En el Tipo NodoArbol:
- **\_\_init__():** Constructor.
- **Tiene hijo izquierdo**.
- **Tiene hijo derecho**.
- **Obtener grado**.
- **Es hoja**.
- **Predecesor de un nodo**: Retorna el nodo predecesor.
- **Sucesor de un nodo**: Retorna el nodo sucesor.

En el Tipo ABB:
- **\_\_init__():** Constructor.
- **Vaciar**.
- **Esta vacio**.
- **Mostrar elementos en PreOrden**.
- **Mostrar elementos en InOrden:** Prueben que pasa si en lugar de ir primero al subarbol izquierdo y luego al subarbol derecho, van primero al derecho y luego al izquierdo.
- **Mostrar elementos en PostOrden**.
- **Insertar elemento:** Inserta nuevo nodo en el lugar que corresponde en el árbol con el elemento que recibe como parámetro.
- **Buscar elemento:** Recibe un elemento y retorna *True* si el elemento esta en el árbol y *False* en caso contrario.
- **Clonar**.
- **Obtener peso del arbol**.
- **Obtener máximo del arbol**.
- **Obtener mínimo del arbol**.
- **Obtener profundidad del árbol:** Altura de la raíz. Deben hacer una operación que calcule la altura de un nodo (del tipo NodoArbol).
- **Obtener profundidad de un elemento (Nivel):** Recibe un elemento y retorna su profundidad si el elemento esta en el árbol y *None* en caso contrario.
"""

from graphviz import Digraph

class NodoArbol:
  def __init__(self, dato = None):
    self.dato = dato
    self.izquierdo = None
    self.derecho = None

  def tieneDer(self):
    return self.derecho != None

  def tieneIzq(self):
    return self.izquierdo != None

  def grado(self):
    gradoNodo = 0
    if self.tieneIzq():
      gradoNodo += 1
    if self.tieneDer():
      gradoNodo += 1
    return gradoNodo

  def esHoja(self):
    return self.grado() == 0

  def insertar(self, nodoNuevo):
    if nodoNuevo.dato < self.dato:
      if self.tieneIzq():
        self.izquierdo.insertar(nodoNuevo)
      else:
        self.izquierdo = nodoNuevo
    elif nodoNuevo.dato > self.dato:
      if self.tieneDer():
        self.derecho.insertar(nodoNuevo)
      else:
        self.derecho = nodoNuevo
    else:
      raise Exception("El elemento ya esta en el arbol")

  def preOrden(self):
    print(self.dato)
    if self.tieneIzq():
      self.izquierdo.preOrden()
    if self.tieneDer():
      self.derecho.preOrden()
    
  def postOrden(self):
    if self.tieneIzq():
      self.izquierdo.postOrden()
    if self.tieneDer():
      self.derecho.postOrden()
    print(self.dato)

  def inOrden(self):
    if self.tieneIzq():
      self.izquierdo.inOrden()
    print(self.dato)
    if self.tieneDer():
      self.derecho.inOrden()
    
  def buscar(self, dato):
    nodoABuscar = None
    if dato == self.dato:
      nodoABuscar = self
    elif dato < self.dato:
      if self.tieneIzq():
        nodoABuscar = self.izquierdo.buscar(dato)
    else:
      if self.tieneDer():
        nodoABuscar = self.derecho.buscar(dato)
    return nodoABuscar

  def peso(self):
    cantNodos = 1
    if self.tieneIzq():
      cantNodos += self.izquierdo.peso()
    if self.tieneDer():
      cantNodos += self.derecho.peso()
    return cantNodos

  def minimo(self):
    nodoMinimo = None
    if self.tieneIzq():
      nodoMinimo = self.izquierdo.minimo()
    else:
      nodoMinimo = self
    return nodoMinimo

  def maximo(self):
    nodoMaximo = None
    if self.tieneDer():
      nodoMaximo = self.derecho.maximo()
    else:
      nodoMaximo = self
    return nodoMaximo

  def altura(self):
    alturaNodo = 0
    if self.grado() == 2:
      alturaNodo = 1 + max(self.izquierdo.altura() , self.derecho.altura())
    elif self.grado() == 1 and self.tieneIzq():
      alturaNodo = 1 + self.izquierdo.altura()
    elif self.grado() == 1 and self.tieneDer():
      alturaNodo = 1 + self.derecho.altura()
    return alturaNodo

  def profundidadDato(self, dato, nivelAct = 0):
    nivelDato = None
    if dato == self.dato:
      nivelDato = nivelAct
    elif dato < self.dato:
      if self.tieneIzq():
        nivelDato = self.izquierdo.profundidadDato(dato, nivelAct+1)
    else:
      if self.tieneDer():
        nivelDato = self.derecho.profundidadDato(dato, nivelAct+1)
    return nivelDato

  def predecesor(self):
    nodoPred = None
    if self.tieneIzq():
      nodoPred = self.izquierdo.maximo()
    return nodoPred

  def sucesor(self):
    nodoSuc = None
    if self.tieneDer():
      nodoSuc = self.derecho.minimo()
    return nodoSuc

  def treePlot(self, dot):
    if self.tieneIzq():
      dot.node(str(self.izquierdo.dato), str(self.izquierdo.dato))
      dot.edge(str(self.dato), str(self.izquierdo.dato))
      self.izquierdo.treePlot(dot)
    else:
      dot.node("None"+str(self.dato)+"l", "None")
      dot.edge(str(self.dato), "None"+str(self.dato)+"l")
    if self.tieneDer():
      dot.node(str(self.derecho.dato), str(self.derecho.dato))
      dot.edge(str(self.dato), str(self.derecho.dato))
      self.derecho.treePlot(dot)
    else:
      dot.node("None"+str(self.dato)+"r", "None")
      dot.edge(str(self.dato), "None"+str(self.dato)+"r")

class ABB:
  def __init__(self):
    self.raiz = None
  
  def estaVacio(self):
    return self.raiz == None

  def vaciar(self):
    self.raiz = None

  def insertar(self, dato):
    nodoNuevo = NodoArbol(dato)
    if self.estaVacio():
      self.raiz = nodoNuevo
    else:
      self.raiz.insertar(nodoNuevo)

  def preOrden(self):
    if not self.estaVacio():
      self.raiz.preOrden()
  
  def inOrden(self):
    if not self.estaVacio():
      self.raiz.inOrden()
  
  def postOrden(self):
    if not self.estaVacio():
      self.raiz.postOrden()

  def buscar(self, dato):
    estaEnArbol = False
    if not self.estaVacio():
      estaEnArbol = self.raiz.buscar(dato) != None
    return estaEnArbol

  def peso(self):
    cantNodos = 0
    if not self.estaVacio():
      cantNodos = self.raiz.peso()
    return cantNodos

  def minimo(self):
    datoMinimo = None
    if not self.estaVacio():
      datoMinimo = self.raiz.minimo().dato
    return datoMinimo

  def maximo(self):
    datoMaximo = None
    if not self.estaVacio():
      datoMaximo = self.raiz.maximo().dato
    return datoMaximo

  def profundidad(self):
    prof = 0
    if not self.estaVacio():
      prof = self.raiz.altura()
    return prof

  def profundidadDato(self, dato):
    profundidadDato = None
    if not self.estaVacio():
      profundidadDato = self.raiz.profundidadDato(dato)
    return profundidadDato

  def treePlot(self, fileName='tree'):
    if not self.estaVacio():
      treeDot = Digraph()
      treeDot.node(str(self.raiz.dato), str(self.raiz.dato))
      self.raiz.treePlot(treeDot)
      treeDot.render(fileName, view=True)

arbol = ABB()
arbol.insertar(20);arbol.insertar(10);arbol.insertar(15);arbol.insertar(30);arbol.insertar(40)
arbol.insertar(12);arbol.insertar(18);arbol.insertar(35);arbol.insertar(38)

#print(arbol.buscar(18))
#print(arbol.buscar(41))
#print(arbol.peso())
#arbol.treePlot()
#print(arbol.minimo())
#print(arbol.profundidadDato(18))
#arbol.inOrden()

arbol.minimo()

class NodoArbol(NodoArbol):
  def eliminar(self, dato):
    if dato < self.dato:
      if self.tieneIzq():
        if self.izquierdo.dato == dato:
          if self.izquierdo.grado() == 2:
            pred = self.izquierdo.predecesor()
            self.izquierdo.eliminar(pred.dato)
            pred.izquierdo = self.izquierdo.izquierdo
            pred.derecho = self.izquierdo.derecho
            self.izquierdo = pred          
          elif self.izquierdo.grado() == 1 and self.izquierdo.tieneIzq():
            self.izquierdo = self.izquierdo.izquierdo
          elif self.izquierdo.grado() == 1 and self.izquierdo.tieneDer():
            self.izquierdo = self.izquierdo.derecho
          else:
            self.izquierdo = None
        else: 
          self.izquierdo.eliminar(dato)
    else:  ###dato > self.dato 
      if self.tieneDer():
        if self.derecho.dato == dato:
          if self.derecho.grado() == 2:
            pred = self.derecho.predecesor()
            self.derecho.eliminar(pred.dato)
            pred.izquierdo = self.derecho.izquierdo
            pred.derecho = self.derecho.derecho
            self.derecho = pred          
          elif self.derecho.grado() == 1 and self.derecho.tieneIzq():
            self.derecho = self.derecho.izquierdo
          elif self.derecho.grado() == 1 and self.derecho.tieneDer():
            self.derecho = self.derecho.derecho
          else:
            self.derecho  = None
        else: 
          self.derecho.eliminar(dato)

class ABB(ABB):
  def eliminar(self, dato):
    if not self.estaVacio():
      if self.raiz.dato == dato:
        if self.raiz.grado() == 2:
          pred = self.raiz.predecesor()
          self.raiz.eliminar(pred.dato)
          pred.izquierdo = self.raiz.izquierdo
          pred.derecho = self.raiz.derecho
          self.raiz = pred
        elif self.raiz.grado() == 1 and self.tieneIzq():
          self.raiz = self.raiz.izquierdo
        elif self.raiz.grado() == 1 and self.tieneDer():
          self.raiz = self.raiz.derecho
        else:
          self.raiz = None
      else:
        self.raiz.eliminar(dato)

arbol = ABB()
arbol.insertar(20);arbol.insertar(10);arbol.insertar(15);arbol.insertar(30);arbol.insertar(40)
arbol.insertar(12);arbol.insertar(18);arbol.insertar(35);arbol.insertar(38);arbol.insertar(80)
arbol.insertar(8);arbol.insertar(5);arbol.insertar(9);arbol.insertar(25);arbol.insertar(21)

arbol.eliminar(30)
arbol.treePlot()

"""### **Ejercicio 2**

Escribir una operación del TDA ABB que calcule la cantidad de hojas de un árbol.
"""



"""### **Ejercicio 3**

Escribir una operación del TDA ABB que muestre los elementos que estan en el nivel N de un ABB, el nivel se recibe por parámetro.
"""



"""### **Ejercicio 4**

Se define por frontera de un árbol, la secuencia formada por los elementos almacenados en las hojas de un árbol, tomados de izquierda a derecha. Escribir una operación del TDA ABB, que imprima por pantalla la frontera del árbol.
"""



"""### **Ejercicio 5**

Escribir una operación del TDA ABB que retorne una lista ordenada (de menor a mayor) con todos los números pares que forman parte del árbol. 
"""



"""### **Ejercicio 6**

Escribir una operación del TDA ABB, que rote el árbol completo, es decir, los elementos del subárbol izquierdo deben ser mayores a la raíz y los del subárbol derecho menores (para todos los nodos del arbol). No se debe retornar un nuevo arbol, sino modificar el arbol desde el que se llama a la operación.
"""

class NodoArbol(NodoArbol):
  def rotar(self):
    self.izquierdo, self.derecho = self.derecho, self.izquierdo
    if self.tieneIzq():
      self.izquierdo.rotar()
    if self.tieneDer():
      self.derecho.rotar()

class ABB(ABB):
  def rotar(self):
    if not self.estaVacio():
      self.raiz.rotar()